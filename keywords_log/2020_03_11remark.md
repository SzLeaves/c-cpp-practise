# 2020.03.11补充
### 实验四的第一题和第四题有一些知识点补充，这里给大家整理了一下

-----------------------------------------------------

* 第一题三个数一起比较大小的最好方式其实是用上条件运算符，形式如下

`[表达式1] ? [表达式2] : [表达式3]`

它的意思是：__计算[表达式1]返回的布尔值，如果为真（ture），则整个条件表达式的值与[表达式2]相同，如果为假（false），则整个条件表达式的值与[表达式3]相同__

这是C语言中唯一一个带有三个运算单元的运算符，实际上它的工作形式是这样的：

假设有两个整数a, b，然后我们需要判断a和b哪个比较大，并把较大的值赋给变量max  
用if-else结构表示就是：
```c
if (a > b)
	max = a;
else
	max = b;
```

用条件运算符表示就是这样：

`max = (a > b) a : b;`

即：**计算(a > b)的返回值，如果为真（也就是a > b），把a的数值赋给max ，如果为假（即b > a），则把b的数值赋给max**，这样max得到的就是a,b中比较大的那个数值了  

原本需要四行代码的两数比较，现在一行就可以写完了。使用条件运算符可以让生成的机器代码更加紧凑，运行效率更高，所以进行三数比较，可以写成这样（三个数分别为a,b,c）：

```c
max = (a >= b)? a : b;
max = (max >= c)? max : c;
printf("最大值是：%d", max);	
```
------------------------------------------------------------

* 第四题如果需要使用随机函数rand()，它会返回一个随机数值，直接调用就可以了  
下面具体解释一下这个函数的用法：

rand()函数不带任何参数，它的函数定义在stdlib.h头文件中，所以使用这个函数时别忘了链接这个头文件哦：  
`#include<stdlib.h>`

之后就可以使用了，比如需要生成一个随机数a可以这么写：  
`int a = rand();`

但是，rand()生成随机数的最大范围在C标准中是用RAND_MAX宏定义规定的，但没有具体定义是哪个数，不同的编译器实现不一样，不过标准中规定了这个宏定义的数值最小值不能小于32767，**所以像刚刚那样直接调用给出的数值结果通常会非常大！**

所以还需要给它定个输出数值的范围，最简单的方法是求rand()返回值的余数

比如需要一个10以内的整数，就可以这么做：  
`int a = rand() % 10;`

看起来似乎没有问题了，但是如果你重复运行这个程序，你会发现它给出的数值全都是一样的，不是随机数了！

原因是：计算机没有办法从内存里面直接随便掏出任意一个数字给你，所谓的随机数，实际上是用算法模拟的，所以这样的随机数被称之为“**伪随机数**”，算法的计算过程直接影响了随机数的产生，确切的说，这会影响到一组随机数中的重复率

rand()返回的数值，实际上是由[某个数值]根据某个算法推算出来的结果（在rand()的实现中，一般会使用是正态分布进行模拟），[某个数值]一般被称为“种子”，这个种子在计算机运行的时候就已经被给定了，且不会改变，所以你如何运行程序，rand()返回的值都是一样的，因为决定它数值的种子没有改变

**所以还需要用上一个srand()函数来改变这个种子的值**，它也是在**stdlib.h**中定义的

这个函数的参数将传递一个unsigned int类型的数值作为种子，我们需要什么种子的值，就直接写在它的参数里面吧，比如像这样：
```c
srand(0);
int a = rand();
```
下面我们做一个小实验看看如何使用这个函数：

我们给它一个循环，让它重复输出十个数字，源代码如下
```c
#include<stdio.h>
#include<stdlib.h>
int main(void) {
	int a, i;
	srand(1);
	for (i = 0; i < 10; i++) {
		a = rand() % 10;
		printf(" %d", a);
	}
	return 0;
}
```
我这里的输出结果是这样的：  
![00.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_11remark/00.jpg)

再重复运行几次？没错！虽然一次运行产生了一组随机的数字，但是重复运行多次后这组数字还是一样的！
srand(1)的参数表明，我们所给定的是一个固定的种子值（数字1）  
所以运行效果跟不加srand()函数是一样的

我们需要让这个种子值变化，怎么办呢，最普遍的方法就是使用**time()**函数的返回值

time()函数的定义在**time.h**头文件中，参数通常会传递0或者NULL，它会根据系统当前的时间，返回一个从1970年1月1号（UTC）到当前日期时刻的秒数，也就是说，这个数值会每隔1秒变化一次。这个精度可以应付大部分的情况了，我们可以这样写：

```c
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main(void) {
	int a, i;
	srand(time(NULL));
	for (i = 0; i < 10; i++) {
		a = rand() % 10;
		printf(" %d", a);
	}
	return 0;
}
```

必要的话，可以在srand()的参数上做强制转换，也就是在time()前面加上(unsigned)标识符：
`srand((unsigned)time(NULL));`

现在我们多运行几次看看：  

![01.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_11remark/01.jpg)

![02.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_11remark/02.jpg)

![03.jpg](https://gitee.com/szleaves/C-Practise/raw/master/keywords_log/pictures/2020_03_11remark/03.jpg)

现在每次运行的每组数值就不一样了
**所以对于第四题，我们可以分别让a,b两个变量取rand()的返回值进行计算，在搭配我们前面讲的两个函数就可以了：**

头文件部分记得写上：
```c
#include<stdlib.h>
#include<time.h>
```


下面是主体：
```c
srand((unsigned)time(NULL));
int a = rand() % 10;
int b = rand() % 10;
......
```

__既然拿到了两个随机的乘数，后面怎么操作，大家应该都懂了吧__

---------------------------------------------------------------

我自己的开源仓库： 
>Github: https://github.com/SzLeaves  
>Gitee:  https://gitee.com/szleaves （备用仓库，不常上去看）


实验四的第二题我在github上托管了我自己写的代码和非常详细的注释，没有思路的同学可以来这里看看：
我这里用了两种方法输出序列

>第一种方法：https://github.com/SzLeaves/C-Practise/blob/master/C7/number_sorting.c  
>第二种方法：https://github.com/SzLeaves/C-Practise/blob/master/C7/number_sorting_v2.c

里面的代码可以直接copy到编译器中运行
